# üèóÔ∏è Arquitetura do Projeto

## üìò Introdu√ß√£o

A arquitetura do sistema **Ingressou** foi planejada para garantir **alta disponibilidade**, **escalabilidade horizontal** e **resili√™ncia** durante picos de acesso ‚Äî especialmente em aberturas de vendas de ingressos.  

O projeto adota uma estrutura **modular e distribu√≠da**, baseada em quatro pilares principais:

- **Load Balancer e Elasticidade**
- **Mensageria (RabbitMQ)**
- **Camada de Cache**
- **Replica√ß√£o de Banco de Dados**

Cada componente foi pensado para suportar o crescimento do sistema e reduzir gargalos de desempenho.

---

## ‚öôÔ∏è Arquitetura Horizontal

O sistema segue o modelo **multi-tier**, com camadas bem definidas:

| Camada | Fun√ß√£o Principal | Exemplos |
|---------|------------------|-----------|
| **Client Tier** | Interface de intera√ß√£o com o usu√°rio. | Navegador e aplicativo mobile. |
| **Web Tier** | Processamento das requisi√ß√µes e l√≥gica de neg√≥cio. | Servidores Node.js/Express. |
| **Data Tier** | Armazenamento persistente e replicado de dados. | PostgreSQL / MySQL. |
| **Infraestrutura de Suporte** | Cache, mensageria e balanceamento. | Redis, RabbitMQ, Nginx. |

---

## üåê Elasticidade e Balanceamento de Carga

A aplica√ß√£o utiliza **balanceamento de carga (load balancing)** para distribuir requisi√ß√µes entre m√∫ltiplos servidores, garantindo maior disponibilidade e desempenho.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/arquitetura.jpeg" width="800">
  <br>
  <em>Figura 1 ‚Äì Elasticidade e Auto Scaling com Load Balancer</em>
</div>

---

**Componentes:**
- **Load Balancer:** distribui as requisi√ß√µes entre os servidores de aplica√ß√£o.  
- **Servidores Web:** processam as requisi√ß√µes simultaneamente.  
- **Auto Scaling:** adiciona ou remove inst√¢ncias de acordo com o tr√°fego.  
- **Cache:** otimiza respostas e reduz o n√∫mero de consultas ao banco.

**Benef√≠cios:**
- Evita sobrecarga em per√≠odos de pico.  
- Aumenta a disponibilidade do sistema.  
- Permite escalabilidade horizontal autom√°tica.

### üîí Gateway/API Edge e Rate Limiting

- API Gateway/BFF com autentica√ß√£o `JWT` (1h) e `refresh token` (7d), rota√ß√£o e revoga√ß√£o.
- Rate limiting e circuit breaker nas bordas (Nginx/Envoy) para proteger contra picos e abuso.
- Idempot√™ncia por chave para endpoints de pagamentos e webhooks.
- CORS, HSTS, CSP e compress√£o (brotli/gzip) habilitados.

---

## üì® Mensageria e Processamento Ass√≠ncrono

O sistema adota **RabbitMQ** para gerenciar filas de mensagens e processamentos em background, como envio de e-mails, gera√ß√£o de QR Codes e notifica√ß√µes.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/mensageria.jpeg" width="800">
  <br>
  <em>Figura 2 ‚Äì Comparativo entre processamento s√≠ncrono e ass√≠ncrono</em>
</div>

---

| Tipo | Descri√ß√£o | Limita√ß√£o |
|------|------------|-----------|
| **Sem processamento ass√≠ncrono** | O servidor executa todas as tarefas em sequ√™ncia, bloqueando o fluxo at√© o t√©rmino. | Lentid√£o e gargalos. |
| **Com processamento ass√≠ncrono** | As tarefas s√£o enviadas para uma fila (RabbitMQ) e processadas por workers independentes. | Necessita gerenciador de filas. |

**Fluxo resumido:**
1. O cliente realiza uma a√ß√£o (ex: compra de ingresso).  
2. O servidor registra a tarefa e envia para a **fila RabbitMQ**.  
3. Um **consumer** processa a tarefa em segundo plano.  
4. O cliente recebe resposta imediata, sem bloqueio da interface.

**Vantagens:**
- Melhora o tempo de resposta da API.  
- Permite execu√ß√£o paralela de tarefas longas.  
- Facilita a escalabilidade de workers.

### Topologias e Fila de Dead Letter (DLQ)

- Exchange do tipo `topic` para orquestrar eventos de: pagamentos, emiss√£o de ingressos (QR), notifica√ß√µes (e-mail/WhatsApp), exporta√ß√µes e transfer√™ncia de ingressos.
- Re-tentativas com backoff exponencial; mensagens envenenadas v√£o para DLQ com alarmes.
- Webhooks externos s√£o processados em workers idempotentes com deduplica√ß√£o.

---

## ‚ö° Camada de Cache

A camada de **cache** atua como intermedi√°ria entre a aplica√ß√£o e o banco de dados, armazenando resultados de consultas frequentes para acesso r√°pido.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/cache.png" width="800">
  <br>
  <em>Figura 3 ‚Äì Fluxo de cache entre servidor e banco de dados</em>
</div>

---

**Funcionamento:**
1. O servidor consulta o cache (ex: Redis).  
2. Se o dado existir, ele √© retornado instantaneamente.  
3. Caso contr√°rio, o servidor busca no banco, armazena o resultado no cache e o entrega ao cliente.

**Exemplo (pseudo-c√≥digo):**
```python
SECONDS = 1
cache.set('evento_123', 'Festival de M√∫sica', 3600 * SECONDS)
cache.get('evento_123')
````

**Vantagens:**
- Reduz drasticamente o tempo de resposta.
- Diminui a carga do banco de dados.
- Ideal para dados est√°ticos ou acessos repetitivos (como lista de eventos).

### Estrat√©gias e Pol√≠ticas de Expira√ß√£o

- TTL recomendado para listagens p√∫blicas (cat√°logo, por cidade/UF/categoria/data): 60‚Äì300s.
- Cache por chave sem√¢ntica (ex.: `event:{slug}`, `events:list:{city}:{uf}:{cat}:{date}`) e por sess√£o para carrinho.
- Invalida√ß√£o dirigida por evento/lote/transfer√™ncia (publica√ß√£o, altera√ß√£o de estoque, conclus√£o de transfer√™ncia).

### üß© Replica√ß√£o de Banco de Dados

A arquitetura de dados utiliza o modelo **Master‚ÄìSlave Replication**, garantindo **leitura distribu√≠da** e **resili√™ncia a falhas**.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/database.jpeg" width="800">
  <br>
  <em>Figura 4 ‚Äì Estrutura de replica√ß√£o de bancos de dados</em>
</div>

---

**Descri√ß√£o:**

- O **Master DB** recebe todas as opera√ß√µes de escrita (INSERT, UPDATE, DELETE).  
- Os **Slave DBs** replicam os dados e tratam apenas opera√ß√µes de leitura.  
- Esse modelo permite que m√∫ltiplos servidores web consultem dados simultaneamente sem sobrecarregar o Master.

**Fluxo:**

1. O servidor escreve no banco Master.  
2. Os Slaves recebem a replica√ß√£o em tempo quase real.  
3. As consultas de leitura s√£o direcionadas preferencialmente aos Slaves.

**Benef√≠cios:**

- Reduz a sobrecarga do banco principal.  
- Melhora a performance em grandes volumes de leitura.  
- Garante alta disponibilidade em caso de falha do Master.  
- Facilita estrat√©gias de **backup**, **failover** e **disaster recovery**.  

### Particionamento e √çndices

- √çndices por `cidade`, `UF`, `data`, `categoria` e `eventoId` para cat√°logos e check-in.
- Particionamento por `eventoId` para tabelas quentes (ex.: `CheckinRegistro`) quando necess√°rio.
- Rotina de manuten√ß√£o (VACUUM/ANALYZE) e monitoramento de planos de execu√ß√£o.

---

### üß† Tecnologias Utilizadas

| **Componente** | **Tecnologia** | **Finalidade** |
|-----------------|----------------|----------------|
| **Balanceador de Carga** | Nginx / AWS ELB | Distribuir requisi√ß√µes entre servidores e otimizar o tr√°fego. |
| **API Gateway / Edge** | Nginx / Envoy / Kong | Autentica√ß√£o JWT, rate limit, roteamento e observabilidade. |
| **Mensageria** | RabbitMQ | Processamento ass√≠ncrono e comunica√ß√£o entre servi√ßos (DLQ/backoff). |
| **Cache** | Redis | Armazenamento tempor√°rio de dados acessados com frequ√™ncia. |
| **Banco de Dados** | PostgreSQL / MySQL | Armazenamento principal com replica√ß√£o Master‚ÄìSlave. |
| **Infraestrutura** | Docker / Kubernetes | Gerenciamento e escalabilidade de containers. |
| **Monitoramento** | Prometheus / Grafana | M√©tricas, alertas e an√°lise de performance em tempo real. |
| **Tracing/Logs** | OpenTelemetry / Loki / Sentry | Tracing distribu√≠do, logs estruturados e erro. |
| **Pagamentos** | Pagar.me (PIX/Cart√£o) | Integra√ß√£o com 3DS, webhooks e split. |
| **E-mail/WhatsApp** | SendGrid / WhatsApp Cloud API | Notifica√ß√µes transacionais de compra e transfer√™ncia. |
| **Armazenamento de Assets** | S3 compat√≠vel + CDN | Banners de eventos, PDFs e imagens p√∫blicas. |
| **Assinatura de QR** | Lib criptogr√°fica (ECDSA/Ed25519) | Assinar e validar payloads antifraude. |
| **CI/CD** | GitHub Actions / ArgoCD | Build, testes, seguran√ßa e deploy cont√≠nuo. |

---

## üóÇÔ∏è Ambientes e Configura√ß√£o

| Ambiente | Objetivo | Pol√≠ticas |
|---|---|---|
| Dev | Desenvolvimento r√°pido | Feature flags liberais, dados sint√©ticos |
| Homolog | Valida√ß√£o com stakeholders | Integra√ß√µes em sandbox, mascaramento de dados |
| Produ√ß√£o | Opera√ß√£o do MVP | Observabilidade completa, backups e SLOs |

- Segredos e chaves gerenciados em cofre (ex.: AWS Secrets Manager/HashiCorp Vault).
- Par√¢metros versionados (ex.: `ParametroSistema`) com vig√™ncia e escopo (global/produtor/evento).

---

## üöÄ Pipeline de Deploy (CI/CD)

1. Lint + testes unit√°rios e de contrato (OpenAPI/Testcontainers).
2. Build de imagens (Docker) com SBOM e varredura de vulnerabilidades (Trivy).
3. Provisionamento IaC (Terraform) para infraestrutura base.
4. Deploy can√°rio/blue‚Äëgreen via ArgoCD/K8s; rollback autom√°tico por SLO.
5. Migra√ß√µes de banco (Flyway) com locks e verifica√ß√£o de integridade.

---

## üî≠ Observabilidade e SLOs

- Tracing distribu√≠do (OpenTelemetry) entre Gateway ‚Üí Services ‚Üí DB/MQ.
- Logs estruturados com correla√ß√£o (traceId/spanId) e PII minimizada.
- M√©tricas de neg√≥cio: taxa de convers√£o, tempo de confirma√ß√£o de pagamento (SLO p95), lat√™ncia de check‚Äëin (SLO p95 < 150ms online), tempo de emiss√£o de ingressos.
- Alertas proativos (pagamentos parados, DLQ crescendo, cache miss rate alto).

---

## üõ°Ô∏è Seguran√ßa e Conformidade

- LGPD: minimiza√ß√£o de dados, anonimiza√ß√£o em logs, consentimento e portabilidade.
- Criptografia em repouso (AES‚Äë256) e em tr√¢nsito (TLS 1.2+). CSP/HSTS/HTTPS only.
- RBAC por pap√©is: `ADMIN`, `PRODUTOR` (somente leitura), `CLIENTE`, `CHECKIN`.
- Assinatura de QR (nonce/expira√ß√£o) e anti‚Äëreplay; verifica√ß√£o offline com listas compactas.

---

## üì¶ Arquivos/Assets e CDN

- Objetos est√°ticos (banners, PDFs) em S3; entrega via CDN com cache e invalida√ß√µes por evento.
- Pol√≠ticas de versionamento e lifecycle (expira√ß√£o de objetos antigos).

---

## üßØ Resili√™ncia, Backups e DR

- Backups di√°rios do banco (retens√£o ‚â• 30 dias) e testes de restaura√ß√£o peri√≥dicos.
- RPO ‚â§ 15 min; RTO ‚â§ 1 h para servi√ßos cr√≠ticos (Gateway, Checkout, Pagamentos, Check‚Äëin).
- Playbooks de incidentes: falha no PSP, satura√ß√£o de filas, queda do cache, falha de n√≥.

---

## üì± Check‚Äëin (PWA) ‚Äî Considera√ß√µes Operacionais

- Modo offline com sincroniza√ß√£o (IndexedDB) e reconcilia√ß√£o de conflitos.
- Pacotes de listas compactas por evento para opera√ß√£o sem rede (janelas curtas).
- M√©tricas locais de lat√™ncia e taxa de sucesso; sincroniza√ß√£o com backoff.

---

### üîö Conclus√£o

A arquitetura do **Ingressou** foi estruturada para suportar **crescimento cont√≠nuo**, **alta concorr√™ncia** e **respostas r√°pidas**, garantindo uma experi√™ncia fluida para o usu√°rio final.

O uso conjunto de **load balancing**, **mensageria ass√≠ncrona**, **cache distribu√≠do** e **replica√ß√£o de banco de dados** forma uma base **s√≥lida e resiliente**, adequada a ambientes de produ√ß√£o com **grande volume de tr√°fego** e **demandas em tempo real**.

Essa abordagem permite escalar horizontalmente, processar tarefas em background de forma eficiente e manter a consist√™ncia dos dados mesmo sob alta carga.

---

### üìö Refer√™ncias

- AWS Architecture Center. *Scalable Web Application Design Patterns*, 2025.  
- RabbitMQ. *Messaging Patterns and Asynchronous Processing*, 2024.  
- Redis Labs. *Caching Strategies for High-Performance Systems*, 2024.  
- DigitalOcean. *Database Replication in Production Environments*, 2023.  

---

## Hist√≥rico de vers√£o

| Vers√£o | Altera√ß√£o | Respons√°vel | Data |
|---:|---|---|---|
| 1.0 | Cria√ß√£o das tabelas 5W+2H gerais e por m√≥dulo (Ingressou) | Gabriel Lima | 16/10/2025 |
