# üèóÔ∏è Arquitetura do Projeto

## üìò Introdu√ß√£o

A arquitetura do sistema **Ingressou** foi planejada para garantir **alta disponibilidade**, **escalabilidade horizontal** e **resili√™ncia** durante picos de acesso ‚Äî especialmente em aberturas de vendas de ingressos.  

O projeto adota uma estrutura **modular e distribu√≠da**, baseada em quatro pilares principais:

- **Load Balancer e Elasticidade**
- **Mensageria (RabbitMQ)**
- **Camada de Cache**
- **Replica√ß√£o de Banco de Dados**

Cada componente foi pensado para suportar o crescimento do sistema e reduzir gargalos de desempenho.

---

## ‚öôÔ∏è Arquitetura Horizontal

O sistema segue o modelo **multi-tier**, com camadas bem definidas:

| Camada | Fun√ß√£o Principal | Exemplos |
|---------|------------------|-----------|
| **Client Tier** | Interface de intera√ß√£o com o usu√°rio. | Navegador e aplicativo mobile. |
| **Web Tier** | Processamento das requisi√ß√µes e l√≥gica de neg√≥cio. | Servidores Node.js/Express. |
| **Data Tier** | Armazenamento persistente e replicado de dados. | PostgreSQL / MySQL. |
| **Infraestrutura de Suporte** | Cache, mensageria e balanceamento. | Redis, RabbitMQ, Nginx. |

---

## üåê Elasticidade e Balanceamento de Carga

A aplica√ß√£o utiliza **balanceamento de carga (load balancing)** para distribuir requisi√ß√µes entre m√∫ltiplos servidores, garantindo maior disponibilidade e desempenho.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/arquitetura.jpeg" width="800">
  <br>
  <em>Figura 1 ‚Äì Elasticidade e Auto Scaling com Load Balancer</em>
</div>

---

**Componentes:**
- **Load Balancer:** distribui as requisi√ß√µes entre os servidores de aplica√ß√£o.  
- **Servidores Web:** processam as requisi√ß√µes simultaneamente.  
- **Auto Scaling:** adiciona ou remove inst√¢ncias de acordo com o tr√°fego.  
- **Cache:** otimiza respostas e reduz o n√∫mero de consultas ao banco.

**Benef√≠cios:**
- Evita sobrecarga em per√≠odos de pico.  
- Aumenta a disponibilidade do sistema.  
- Permite escalabilidade horizontal autom√°tica.

---

## üì® Mensageria e Processamento Ass√≠ncrono

O sistema adota **RabbitMQ** para gerenciar filas de mensagens e processamentos em background, como envio de e-mails, gera√ß√£o de QR Codes e notifica√ß√µes.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/mensageria.jpeg" width="800">
  <br>
  <em>Figura 2 ‚Äì Comparativo entre processamento s√≠ncrono e ass√≠ncrono</em>
</div>

---

| Tipo | Descri√ß√£o | Limita√ß√£o |
|------|------------|-----------|
| **Sem processamento ass√≠ncrono** | O servidor executa todas as tarefas em sequ√™ncia, bloqueando o fluxo at√© o t√©rmino. | Lentid√£o e gargalos. |
| **Com processamento ass√≠ncrono** | As tarefas s√£o enviadas para uma fila (RabbitMQ) e processadas por workers independentes. | Necessita gerenciador de filas. |

**Fluxo resumido:**
1. O cliente realiza uma a√ß√£o (ex: compra de ingresso).  
2. O servidor registra a tarefa e envia para a **fila RabbitMQ**.  
3. Um **consumer** processa a tarefa em segundo plano.  
4. O cliente recebe resposta imediata, sem bloqueio da interface.

**Vantagens:**
- Melhora o tempo de resposta da API.  
- Permite execu√ß√£o paralela de tarefas longas.  
- Facilita a escalabilidade de workers.

---

## ‚ö° Camada de Cache

A camada de **cache** atua como intermedi√°ria entre a aplica√ß√£o e o banco de dados, armazenando resultados de consultas frequentes para acesso r√°pido.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/cache.png" width="800">
  <br>
  <em>Figura 3 ‚Äì Fluxo de cache entre servidor e banco de dados</em>
</div>

---

**Funcionamento:**
1. O servidor consulta o cache (ex: Redis).  
2. Se o dado existir, ele √© retornado instantaneamente.  
3. Caso contr√°rio, o servidor busca no banco, armazena o resultado no cache e o entrega ao cliente.

**Exemplo (pseudo-c√≥digo):**
```python
SECONDS = 1
cache.set('evento_123', 'Festival de M√∫sica', 3600 * SECONDS)
cache.get('evento_123')
````

**Vantagens:**
- Reduz drasticamente o tempo de resposta.
- Diminui a carga do banco de dados.
- Ideal para dados est√°ticos ou acessos repetitivos (como lista de eventos).

### üß© Replica√ß√£o de Banco de Dados

A arquitetura de dados utiliza o modelo **Master‚ÄìSlave Replication**, garantindo **leitura distribu√≠da** e **resili√™ncia a falhas**.

<div align="center">
  <img src="assets/DesignSprint/Arquitetura/database.jpeg" width="800">
  <br>
  <em>Figura 4 ‚Äì Estrutura de replica√ß√£o de bancos de dados</em>
</div>

---

**Descri√ß√£o:**

- O **Master DB** recebe todas as opera√ß√µes de escrita (INSERT, UPDATE, DELETE).  
- Os **Slave DBs** replicam os dados e tratam apenas opera√ß√µes de leitura.  
- Esse modelo permite que m√∫ltiplos servidores web consultem dados simultaneamente sem sobrecarregar o Master.

**Fluxo:**

1. O servidor escreve no banco Master.  
2. Os Slaves recebem a replica√ß√£o em tempo quase real.  
3. As consultas de leitura s√£o direcionadas preferencialmente aos Slaves.

**Benef√≠cios:**

- Reduz a sobrecarga do banco principal.  
- Melhora a performance em grandes volumes de leitura.  
- Garante alta disponibilidade em caso de falha do Master.  
- Facilita estrat√©gias de **backup**, **failover** e **disaster recovery**.  

---

### üß† Tecnologias Utilizadas

| **Componente** | **Tecnologia** | **Finalidade** |
|-----------------|----------------|----------------|
| **Balanceador de Carga** | Nginx / AWS ELB | Distribuir requisi√ß√µes entre servidores e otimizar o tr√°fego. |
| **Mensageria** | RabbitMQ | Processamento ass√≠ncrono e comunica√ß√£o entre servi√ßos. |
| **Cache** | Redis | Armazenamento tempor√°rio de dados acessados com frequ√™ncia. |
| **Banco de Dados** | PostgreSQL / MySQL | Armazenamento principal com replica√ß√£o Master‚ÄìSlave. |
| **Infraestrutura** | Docker / Kubernetes | Gerenciamento e escalabilidade de containers. |
| **Monitoramento** | Prometheus / Grafana | M√©tricas, alertas e an√°lise de performance em tempo real. |

---

### üîö Conclus√£o

A arquitetura do **Ingressou** foi estruturada para suportar **crescimento cont√≠nuo**, **alta concorr√™ncia** e **respostas r√°pidas**, garantindo uma experi√™ncia fluida para o usu√°rio final.

O uso conjunto de **load balancing**, **mensageria ass√≠ncrona**, **cache distribu√≠do** e **replica√ß√£o de banco de dados** forma uma base **s√≥lida e resiliente**, adequada a ambientes de produ√ß√£o com **grande volume de tr√°fego** e **demandas em tempo real**.

Essa abordagem permite escalar horizontalmente, processar tarefas em background de forma eficiente e manter a consist√™ncia dos dados mesmo sob alta carga.

---

### üìö Refer√™ncias

- AWS Architecture Center. *Scalable Web Application Design Patterns*, 2025.  
- RabbitMQ. *Messaging Patterns and Asynchronous Processing*, 2024.  
- Redis Labs. *Caching Strategies for High-Performance Systems*, 2024.  
- DigitalOcean. *Database Replication in Production Environments*, 2023.  

---

## Hist√≥rico de vers√£o

| Vers√£o | Altera√ß√£o | Respons√°vel | Data |
|---:|---|---|---|
| 1.0 | Cria√ß√£o das tabelas 5W+2H gerais e por m√≥dulo (Ingressou) | Gabriel Lima | 16/10/2025 |
